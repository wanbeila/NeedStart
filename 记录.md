### 理论上的7层网络结构

* OSI参考模型

| 序   | 名称       | 相关协议                             | 描述               |
| ---- | ---------- | ------------------------------------ | ------------------ |
| 7    | 应用层     |                                      |                    |
| 6    | 表示层     |                                      |                    |
| 5    | 会话层     |                                      |                    |
| 4    | 传输层     | TCP、UDP                             | 差错控制、流量控制 |
| 3    | 网络层     | ICMP、IGMP、IP、OSPF、BGP、ARP、RARP | 路由选择           |
| 2    | 数据链路层 |                                      |                    |
| 1    | 物理层     | ISO2110、IEEE802                     |                    |

* TCP/IP 五层模型

网络接口层（物理层，数据链路层）

IP层

传输层

应用层

### 如何进行拥塞控制

首先拥塞控制是在传输层实现的，而网络拥塞主要是发生在使用TCP协议场景下，对网络中的某一资源的需求超过了该资源所能提供的能力，就会发生网络拥塞。

TCP的四种拥塞控制算法

1、慢开始

发送方每次发送报文数量等于发送拥塞窗口大小，每当接收到响应，则根据收到响应的数量增加窗口大小，直到窗口大小等于慢开始门限值，此时进入拥塞避免算法

>例如，一开始发送方的swnd大小为1，发送后收到响应，则增加到2，发送两个请求，收到后，增加到4，依次类推，直到swnd=ssthresh

2、拥塞避免

在拥塞避免算法下，swnd的大小按照线性进行增加，依次加一

3、快重传

4、快恢复



## 代理

### 1 静态代理

继承需要代理的类，重写基类方法，

### 2 jdk 动态代理

实现接口

### 3 cglib 动态代理 

继承被代理类



## 集合

1 关于hashmap中出现的取余运算      a % b 等价于 a & (b - 1)，取余相当于是将大于的部分数据都丢弃  hashcode % length  hashcode & (length - 1)

2 hashmap中的 hash 方法，之所以使用了  hashcode ^ (hashcode >>> 16) 是因为上面的取余计算基本上只使用到了 低 16 位的数据（length在16位时已经有65536），这里是为了让高16位加入进来与低16位进行异或运算增加低位信息的随机性，以及hash值的复杂度

